---
title: "Data Structures"
teaching: 60
exercises: 25
source: Rmd
---

::::::::::::::::::::::::::::::::::::::: objectives

- To begin exploring data frames, and be able to visualize them in Rstudio.
- To be able to ask questions from R about the type, class, and structure of an object.
- To understand how to add rows or columns to a data frame.
- To understand how to subset parts of data frames.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- How can I read data in R?
- What are the basic data types in R?
- How can I manipulate a data frame?

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r, include=FALSE}
options(stringsAsFactors = FALSE)
cats_orig <- data.frame(coat = c("calico", "black", "tabby"), weight = c(2.1, 5, 3.2), likes_catnip = c(1, 0, 1), stringsAsFactors = FALSE)
cats_bad <- data.frame(coat = c("calico", "black", "tabby", "tabby"), weight = c(2.1, 5, 3.2, "2.3 or 2.4"), likes_catnip = c(1, 0, 1, 1), stringsAsFactors = FALSE)
cats <- cats_orig
```

One of R's most powerful features is its ability to deal with tabular data -
such as you may already have in a spreadsheet or a CSV file. Let's start by
making a toy dataset in your `data/` directory, called `feline-data.csv`:

```{r}
cats <- data.frame(coat = c("calico", "black", "tabby"),
                    weight = c(2.1, 5.0, 3.2),
                    likes_catnip = c(1, 0, 1))
```

Let's now view the cats data frame. We can to this a number of different ways. The first two commands print the data in your R console,
while using the View command will open a separate tab with the data (next to your script name at the top).

```{r}
cats

print(cats)

View(cats)
```

### Data Types

We can now ask R about the structure of our dataframe — variables (columns) may be numbers, characters, or factors
using the structure (str) command.

```{r}
str(cats)
```

R works with various data types, including numeric and character variables. 
These are numbers and strings (e.g. words) respectively.

A third kind of data type, factors are categorical variables that only take on 
finite, discrete values. These are useful when we want to group entries of a 
dataset together. For example, if we were interested in asking questions like:

Does whether cats like catnip affect metrics like their weight?

Let's start by isolating the "likes_catnip" column visually using the $ function.

```{r}
cats$likes_catnip
```

Now, we can convert this to a factor, and view its structure

```{r}
factor_catnip <-as.factor(cats$likes_catnip)

str(factor_catnip)
```

### Adding rows and columns to data frames

We can now use the cbind (column binding) function to add this to our cats dataset

```{r}
cbind(cats, factor_catnip)
```

And we can add this permanently to our cats data frame by modifying the code slightly

```{r}
cats <- cbind(cats, factor_catnip)
```

Finally, let's add a fourth piece of information to our data frame as a fifth column.

```{r}
age <- c(2, 3, 5)
cats
```

We can then add this as a column via:

```{r}
cbind(cats, age)
```

Note that if we tried to add a vector of ages with a different number of entries than the number of rows in the data frame, it would fail:

```{r, error=TRUE}
age <- c(2, 3, 5, 12)
cbind(cats, age)

age <- c(2, 3)
cbind(cats, age)
```

Why didn't this work? Of course, R wants to see one element in our new column
for every row in the table:

```{r}
nrow(cats)
length(age)
```

So for it to work we need to have `nrow(cats)` = `length(age)`. Let's overwrite the content of cats with our new data frame.

```{r}
age <- c(2, 3, 5)
cats <- cbind(cats, age)

cats
```

Now how about adding rows? We already know that the rows of a
data frame are lists:

```{r}
newRow <- list("tortoiseshell", 3.3, TRUE, 1, 9)
cats <- rbind(cats, newRow)
```

Let's confirm that our new row was added correctly. 

```{r}
cats
```

We can now save `cats` as a CSV file. It is good practice to call the argument
names explicitly so the function knows what default values you are changing. Here we
are setting `row.names = FALSE`. Recall you can use `?write.csv` to pull
up the help file to check out the argument names and their default values.

##################################################################################################

NOTE TO SELF : this is not presently working. I can get this to work for the github just fine, but will need to coordinate with Amanda on
the file directory we are expecting students to set up

##################################################################################################

```{r}
write.csv(cats, "data/feline-data.csv")
```

### Reading in larger datafiles

Okay, so now we are going to be working with a larger data set — the Gapminder data set, which contains
hundreds of global development indicators for countries across the globe.

First, make sure that the gapminder_data.csv file is saved in your data folder.

```{r, include=FALSE}
gapminder <- read.csv("data/gapminder_data.csv", header = TRUE)
```

Let's look at the data!

```{r, include=FALSE}
gapminder

View(gapminder)
```

As you can see this is a huge dataset! Let's first find out just how many entries it contains, then look only at its first few entires

```{r, include=FALSE}
nrow(gapminder)

head(gapminder)
```

We can also examine its last rows using the tail function.

```{r, include=FALSE}
tail(gapminder)
```

### Subsetting data frames numerically

When working with large datasets like this, you may often want to visualize smaller sections of the data frame, by subsetting
it based on row and column number. Starting with columns only, we can use the following syntax to only show the 1st column of the data.
Note that the space before the comma in the square brackets [,] is empty because we are asking R to show us the entries for every row.

```{r, include=FALSE}
gapminder[,1]
```

We can now ask R to show us the entries for the 2nd through 4th columns, using a continuous span of numbers.

```{r, include=FALSE}
gapminder[,2:4]
```

Now we will move on to specifiying which rows of the data frame to pull up. This number appears before the comma. Leaving the column number
(ie. the entry after the comma) means that data will be displayed for all columns of the row(s) specified.

```{r, include=FALSE}
gapminder[1,]
```

Here again, we can specify a range of numbers to pull several rows at once. Let's try calling the data for the 100th through 109th entries:

```{r, include=FALSE}
gapminder[100:109,]
```

:::::::::::::::::::::::::::::::::::::::  challenge

### Challenge 1

One of the most important parts of data analysis in R is ensuring that your data
frame contains the information you think it does, and that it is correctly
formatted. Here, we will look at our gapminder dataset and execute some of the
data investigation tools we have gone over so far. 

#### Copy the code template

Create a new script in RStudio and copy and paste the following code. Then
move on to the tasks below, which help you to fill in the gaps (\_\_\_\_\_\_).

# JASON: I closed your ``` & your challenge chunk below 
```
```

Using the object `gapminder`:

# 1. Print the data
_____

# 2. Show an overview of the table with all data types
_____(gapminder)

# 3. Isolate the country, year, and population data for the 45th through 54th rows
____________

# 4. Create another country column, "country.fac", that contains country as 
a factor data type
_____

### Instructions for the tasks

#### 1\. Print the data

Print the data to the
console

:::::::::::::::  solution
:::::::::::::::
:::::::::::::::::::::::::::::::::::::::


### Tip 1.1

Show the content of any data frame by typing its name.


### Solution to Challenge 1.1

Two correct solutions:

```
gapminder
print(gapminder)
```



#### 2\. Overview of the data types

The data type of your data is as important as the data itself. Use a
function we saw earlier to print out the data types of all columns of the
`gapminder` `data.frame`.

:::::::::::::::  solution

### Tip 1.2

In the chapter "Data types" we used a function to look at data types in our
cats data frame.


:::::::::::::::::::::::::

> ### Solution to Challenge 1.2
> 
> ```
> str(gapminder)
> ```

#### 3\. Print the country, year, and population data for the 45th through 54th rows

:::::::::::::::  solution

### Tip 1.3

Use the head() or tail() command to remind yourself of where these columns fall
in the dataset.

Revisit the "Subsetting data frames numerically" chapter for help specifying
how to enter the required row and column numbers. 


:::::::::::::::::::::::::

### Solution to Challenge 1.3

gapminder[45:54,1:3]

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::  solution

### Tip 1.4

At the end of the "Data types" chapter we converted a column of our cats
data frame to a factor.

At the beginning of the "### "Adding rows and columns to data frames" we then
added this back to our cats data frame. 


:::::::::::::::::::::::::

> ### Solution to Challenge 1.4
> 
> ```
> country.fac <- as.factor(gapminder$country)
> gapminder <- cbind(gapminder, country.fac)
> ```

### Subsetting data frames based on entries

In a large dataset like this one, you might be interested in asking questions
about a particular category or entry of the data. Here, for example, one could
isolate data for a particular country of interest. 

We need to use our countries listed as a factor level for this to work.

##################################################

THIS ISNT WORKING IN THE CHUNK, BUT IS IN THE CONSOLE????


```{r, include=FALSE}
levels(gapminder$country.fac)
```

Each of you can pick a country you are interested in honing in on, and we will 
now each extract entries for that particular country.

This first involves using a logical operator to determine whether country entries
match your country of interest.

Let's start by working with the top (head) of the dataset:

```{r, include=FALSE}
head(gapminder)

head(gapminder$country.fac=="Afghanistan")

head(gapminder$country.fac=="Vietnam")
```

As you can see, this returns a "TRUE" or "FALSE" value depending on whether the 
entry matches what you have specified. We can now use this same approach to 
isolate parts of the gapminder dataset for a specific country.

Here we are need to insert this logical function into the subsetting formula
we used earlier ([rows, columns]).

```{r, include=FALSE}
gapminder[gapminder$country.fac=="Panama",]
```

Finally, we can register this subsetted data frame as its own entry if desired.
```{r, include=FALSE}
gapminder.panama <- gapminder[gapminder$country.fac=="Panama",]

gapminder.panama
```

